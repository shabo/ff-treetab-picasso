#!/usr/bin/env node
/* eslint-disable no-console */

import fs from 'node:fs';
import path from 'node:path';

function titleCaseLoose(s) {
  if (!s) return s;
  return s.slice(0, 1).toUpperCase() + s.slice(1);
}

function readJson(p) {
  return JSON.parse(fs.readFileSync(p, 'utf8'));
}

const ROOT = path.resolve(process.cwd());
const dataPath = path.join(ROOT, 'node_modules', 'emojibase-data', 'en', 'data.json');
const messagesPath = path.join(ROOT, 'node_modules', 'emojibase-data', 'en', 'messages.json');
const outPath = path.join(ROOT, 'src', 'emoji-data.js');

if (!fs.existsSync(dataPath)) {
  console.error(`Missing ${dataPath}. Did you run npm install?`);
  process.exit(1);
}

const data = readJson(dataPath);
const messages = readJson(messagesPath);

// messages.groups is ordered; emoji entries reference group by index.
const groups = (messages.groups || []).slice().sort((a, b) => (a.order ?? 0) - (b.order ?? 0));
const groupByIndex = groups;

function groupKeyForEntry(e) {
  if (typeof e.group === 'number' && groupByIndex[e.group]) return groupByIndex[e.group].key;
  // Some components (regional indicators) are missing group metadata in this dataset.
  return 'component';
}

// Build grouped emoji list (base emoji only; skin variants are attached to the base).
const byGroup = new Map();
for (const g of groups) byGroup.set(g.key, []);
if (!byGroup.has('component')) byGroup.set('component', []);

for (const e of data) {
  // Skip "text" presentation only entries.
  if (!e || typeof e.emoji !== 'string' || e.emoji.length === 0) continue;

  const groupKey = groupKeyForEntry(e);
  const entry = {
    emoji: e.emoji,
    label: e.label || '',
    group: groupKey,
    tags: Array.isArray(e.tags) ? e.tags : [],
    skins: Array.isArray(e.skins) ? e.skins.map((s) => s.emoji).filter(Boolean) : []
  };

  const arr = byGroup.get(groupKey) || [];
  arr.push(entry);
  byGroup.set(groupKey, arr);
}

const outGroups = [];
for (const g of groups) {
  outGroups.push({
    key: g.key,
    label: titleCaseLoose(g.message || g.key),
    emojis: byGroup.get(g.key) || []
  });
}

// Ensure "component" exists even if dataset group order differs.
if (!outGroups.find((g) => g.key === 'component')) {
  outGroups.splice(2, 0, { key: 'component', label: 'Components', emojis: byGroup.get('component') || [] });
}

const payload = {
  generatedAt: new Date().toISOString(),
  groups: outGroups
};

const banner =
  '/* This file is generated by scripts/gen_emoji_data.mjs. */\n' +
  '/* Do not edit by hand. */\n';

const js = banner + `window.TABS_COLOR_EMOJI_DATA = ${JSON.stringify(payload)};\n`;

fs.writeFileSync(outPath, js, 'utf8');
console.log(`Wrote ${outPath} (${js.length} bytes)`);

